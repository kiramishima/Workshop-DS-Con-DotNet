#!markdown

# Intro Notebooks con F#

Tenemos varias opciones, como escribir codígo o usar Markdown para escribir nuestros articulos y despues mostrar nuestros resultados gracias a la ejecución del codígo.
En este Workshop trabajaremos el caso de nuestro cliente Tailwind Sports.

Así que lo primero que haremos sera cargar nuestras librerías a este espacio de trabajo.

#!markdown

## Trabajando con Nuget Packages desde un Notebook

Para usar las librerias de nuget haremos uso de la siguiente sintaxis : 

```
#r "<nuget package>, <nuget package version>"
```

En este proyecto utilizaremos las sig. librerías:


1. FSharp.Data : Nos permitira trabajar con servicios externos de manera facil.
2. Deedle : Inspirada en pandas, nos permitira trabajar con Dataframes.
3. Plotly.NET : Nos permite crear graficos en HTML muy similar a lo que hace Bokeh y Matplotlib en Python.
4. Newtonsoft.Json : Libreria para trabajar con JSON 

#!fsharp

#r "nuget:FSharp.Data"
#r "nuget:Deedle"
#r "nuget: Plotly.NET, 2.0.0-preview.14"
#r "nuget: Plotly.NET.Interactive, 2.0.0-preview.14"
#r "nuget: Newtonsoft.Json"

#!markdown

# Cargando datos en un Dataframe con Deedle

### Para cargar datos desde un archivo, usaremos Deedle, importamos el namespace de Deedle, y posteriormente usamos la siguiente sintaxis:

```
using Deedle;

var df = Deedle.Frame.ReadCsv("archivo.csv", separators: ",", hasHeaders: true);

# hasHeaders en caso de que el archivo CSV cuente con headers en la primera fila
# separators indica el tipo de separadores usados en el CSV, comunmente veremos ",", ";" , "\t" , etc 
```

En este taller usaremos el archivo `tailwind_sports_db.csv` que se encuentra en el directorio de DATASET

#!fsharp

open Deedle
open System
open System.Globalization

let df = Frame.ReadCsv(@"../DATASET/tailwind_sports_db.csv", separators=",", hasHeaders= true)

#!markdown

#### Para visualizar los primeros 5 registros del dataframe, debemos usar la propiedad `Rows` y su metodo `Between`. Para imprimir usamos el metodo `Print` al final.


dataframe.<b style="color: purple;">Rows</b>.<b style="color: blue;">Between</b>(<b style="color: green;">indice 1</b>, <b style="color: orange;">indice 2</b>).**Print**()

#!fsharp

df.Rows.Between(0, 5).Print()

#!markdown

#### Para visualizar el listado de columnas que tiene nuestro Dataframe, usamos la propiedad `Columns` y su propiedad `Keys`. Usando el comodin especial `display` podemos visualizar el resultado en el notebook.


<b style="color: orange;">display</b><b style="color: green;">(</b>**dataframe**.<b style="color: purple;">Columns</b>.<b style="color: blue;">Keys</b><b style="color: green;">)</b>

#!fsharp

display(df.Columns.Keys)

#!markdown

# Ventas Totales

De acuerdo al documento, Tailwind Sports desea conocer el total de las ventas, para ello debemos hacer la suma de nuestra columna `Ingreso` y aplicar la operacion suma. Así que para seleccionar una columna en especifico de un dataframe, usaremos la siguiente sintaxis:

<b style="color: blue;">df</b>[<b style="color: orange;">columna</b>];

Para aplicar la suma podemos la propiedad `Values`, el cual nos va regresar un Enumerable del tipo de dato, y podemos aplicar `Sum` de `System.Linq` y obtener el resultado. Pero para evitar hacer todo eso, usaremos la clase `Stats` y su metodo `sum`, al cual le pasamos la Serie seleccionada. Ejemplo:

<b style="color: green;">Stats</b>.**sum**(<b style="color: blue;">df</b>[<b style="color: orange;">columna</b>]);

#!fsharp

let x = df.GetColumn("Ingreso") |> Stats.sum
let vTotal = x.ToString "C"
display($"Ventas Totales: {vTotal}")

#!markdown

# Integracion de las ventas totales

Si **$2,571,850.00** representa las ventas totales, queremos ver como se divide ese total entre compras y devoluciones. Para ello ocupamos filtrar por el `Tipo de Orden` . Para ello usaremos el metodo `FilterRowsBy` el cual recibe `columna a filtrar` y `valor a filtrar`.

var df_filtrado = dataframe.<b style="color: purple;">FilterRowsBy</b>(<b style="color: blue;">"columna"</b>, <b style="color: green;">"Valor"</b>)

var serieFiltrada = dataframe.<b style="color: purple;">FilterRowsBy</b>(<b style="color: blue;">"columna"</b>, <b style="color: green;">"Valor"</b>).[<b style="color: orange;">"Columna"</b>]

#!fsharp

let compras = df.FilterRowsBy("Tipo Orden", "Compra").["Ingreso"] |> Stats.sum
let percCompras = compras / x
let devoluciones = df.FilterRowsBy("Tipo Orden", "Devolucion").["Ingreso"] |> Stats.sum
let percDevoluciones = devoluciones / x

type IntegracionVentasPerc(compra, pcompra, devolucion, pdevolucion, total) =
    member this.Compra = compra
    member this.PercCompra = pcompra
    member this.Devoluciones = devolucion
    member this.PercDevoluciones = pdevolucion
    member this.Total = total

let integracion = IntegracionVentasPerc(compras.ToString("C"), percCompras.ToString("0.00%"), devoluciones.ToString("C"), percDevoluciones.ToString("0.00%"), x.ToString("C"))

display(integracion)

#!markdown

# Graficar las ventas mensuales

En este apartado procederemos a usar Plotly. Para ello debemos importar el namespace Plotly.NET , el cuál contiene todas las funciones necesarias para renderizar nuestras grafícas. A continuacion mostraremos la sintaxis basíca para una grafica de columnas o barras.

```fsharp

open Plotly.NET
open Plotly.NET.LayoutObjects
open Plotly.NET.TraceObjects

// valores
let x =  [|10; 20; 30; 40; 50 |]
let y = [| "A"; "B"; "C"; "D"; "E" |];


// Le damos mas estilo
let mirroredXAxis =
    LinearAxis.init(
        Title = Title.init(Text="Texto Eje X"),
        ShowLine = true,
        Mirror = StyleParam.Mirror.AllTicks,
        ShowGrid = false,
        Ticks = StyleParam.TickOptions.Inside
    )

let mirroredLogYAxis = 
    LinearAxis.init(
        Title = Title.init(Text="Texto Eje Y"),
        AxisType = StyleParam.AxisType.Auto,
        ShowLine = true,
        Mirror = StyleParam.Mirror.AllTicks,
        ShowGrid = false,
        Ticks = StyleParam.TickOptions.Inside
    )

let chart_layout = 
    let tmp = Layout()
    tmp?title<- "Titulo Grafica"
    tmp?xaxis<- mirroredXAxis
    tmp?yaxis<- mirroredLogYAxis
    tmp

let colors = x2 |> Array.map (fun name -> match name with
                                                                |"A" -> Color.fromString "green"
                                                                |"B" -> Color.fromString "blue"
                                                                |"C" -> Color.fromString "red"
                                                                |"D" -> Color.fromString "brown"
                                                                |_ -> Color.fromString "deeppink") |> Color.fromColors

let markers = Marker.init(Color=colors)

// Creamos el grafico
Chart.Column(y,x)
    |> Chart.withLineStyle(Width=2.,Dash=StyleParam.DrawingStyle.Dot)
    |> Chart.withLayout chart_layout
    |> Chart.withMarker markers
```

Antes de graficar, debemos agrupar nuestra informacion, para ello usaremos el metodo `groupRowsUsing` del modulo `Frame` el cual recibe una lambda donde el primer elemento es el indice y el segundo elemento son los elementos de nuestro dataframe.

```fsharp

// Ejemplo
let data = df |> Frame.groupRowsUsing(fun selector frame -> frame.GetAs<Type>("Columna"))
   |> Frame.nest
   |> Series.observations
   |> Seq.map (fun ((m, y), frame) ->
        // operacion
   |> Seq.toList

```

Una vez agrupados, aplicamos el metodo `nest` del modulo `Frame` para crear una tupla entre el nuevo indice de la agrupacion y los valores que pertenecen a ese conjunto de datos. Posteriormente el metodo `observations` del modulo `Series` convertimos el resultado en `key` - `value`.
Finalmente con el modulo Seq recorremos el arreglo y armamos la salida para finalmente convertirlo a lista.

#!fsharp

// Como Fecha esta en tipo String habra que reconvertirlo a tipo Date
let dts = df.GetColumn<string>("Fecha").Values |> Seq.map (fun x -> DateTime.Parse x)
df?Fecha <- dts

type MesVenta(mes, venta) =
    member this.Mes = mes
    member this.Venta = venta

// Agrupamos x mes
let getMonthName (month:int) =
    CultureInfo.CurrentCulture.DateTimeFormat.GetMonthName month

let data = df |> Frame.groupRowsUsing(fun _ c -> c.GetAs<DateTime>("Fecha").Month |> getMonthName)
        |> Frame.nest
        |> Series.observations
        |> Seq.map (fun (m, frame) ->
            // m,
            MesVenta(m, frame.["Ingreso"] |> Stats.sum)
            )
        |> Seq.toList

display(data)

#!fsharp

open Plotly.NET
open Plotly.NET.LayoutObjects
open Plotly.NET.TraceObjects

// Obteniendo los valores
let x = data |> List.map (fun x -> x.Mes) |> List.toArray 
let y = data |> List.map (fun x -> x.Venta) |> List.toArray

let mirroredXAxis =
    LinearAxis.init(
        Title = Title.init(Text="Meses"),
        ShowLine = true,
        Mirror = StyleParam.Mirror.AllTicks,
        ShowGrid = false,
        Ticks = StyleParam.TickOptions.Inside
    )

let mirroredLogYAxis = 
    LinearAxis.init(
        Title = Title.init(Text="Ingreso"),
        AxisType = StyleParam.AxisType.Auto,
        ShowLine = true,
        Mirror = StyleParam.Mirror.AllTicks,
        ShowGrid = false,
        Ticks = StyleParam.TickOptions.Inside
    )

let chart_layout = 
    let tmp = Layout()
    tmp?title<- "Ventas Mensuales"
    tmp?xaxis<- mirroredXAxis
    tmp?yaxis<- mirroredLogYAxis
    tmp

Chart.Line(
        x,y,
        ShowMarkers=true,
        MarkerSymbol=StyleParam.MarkerSymbol.Square)
    |> Chart.withLineStyle(Width=2.,Dash=StyleParam.DrawingStyle.Dot)
    |> Chart.withLayout chart_layout

#!markdown

## Finalmente , nuestro ultimo requerimiento consiste en graficar el comportamiento de sus ventas en las diferentes plataformas donde vende sus productos la empresa.

Para ello agruparemos sobre la columna: **Plataforma**

#!fsharp

// codigo agrupacion

#!fsharp

// codigo grafica
